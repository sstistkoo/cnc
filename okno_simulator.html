<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interaktivn√≠ kart√©zsk√° m≈ô√≠≈æka</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none; /* Disable browser's default touch actions */
        }
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden;
            transition: transform 0.3s ease-in-out;
        }
        #canvas-container.panel-open {
            transform: translateY(calc(-1 * var(--panel-height, 50vh)));
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; /* Zak√°≈æe z√°kladn√≠ dotykov√© chov√°n√≠, abychom mohli implementovat vlastn√≠ */
        }
        .controls {
            position: absolute;
            top: 60px; /* Posunuto v√Ω≈°e, aby nezasahovalo do p≈ôehr√°vaƒçe na mobilu */
            right: 20px;
            background-color: rgba(255, 255, 255, 0.5); /* Zv√Ω≈°en√° pr≈Øhlednost na 50% */
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            transition: transform 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .controls.hidden {
            display: none;
        }
        
        .controls.panel-open {
            transform: translateY(calc(-1 * var(--panel-height, 50vh) + 240px));
        }
        .controls button {
            margin: 2px;
            width: 40px;
            height: 30px;
            line-height: 1;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px 12px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            font-size: 14px; /* Vƒõt≈°√≠ text pro lep≈°√≠ ƒçitelnost na mobiln√≠ch za≈ô√≠zen√≠ch */
            z-index: 1000;
        }
        @media (max-width: 768px) {
            .controls {
                top: 100px; /* Je≈°tƒõ v√Ω≈°e na mobiln√≠ch za≈ô√≠zen√≠ch */
                right: 15px;
                padding: 8px;
            }
            .controls button {
                padding: 12px 16px; /* Je≈°tƒõ vƒõt≈°√≠ tlaƒç√≠tka na mal√Ωch obrazovk√°ch */
                margin: 4px;
                width: 50px; /* Vƒõt≈°√≠ tlaƒç√≠tka na dotykov√©m za≈ô√≠zen√≠ */
                height: 50px;
                font-size: 24px;
            }
            .coordinates {
                font-size: 16px; /* Vƒõt≈°√≠ text na mobiln√≠ch za≈ô√≠zen√≠ch */
            }
        }

        /* Styly pro vysouvac√≠ panel */
        .sliding-panel {
            position: fixed;
            bottom: -50vh; /* Zmƒõnƒõno z pevn√© hodnoty na relativn√≠ */
            left: 0;
            width: 100%; /* Panel p≈ôes celou ≈°√≠≈ôku */
            height: 50vh; /* V√Ωchoz√≠ v√Ω≈°ka je 50% v√Ω≈°ky obrazovky */
            background-color: rgba(255, 255, 255, 0.5); /* Zv√Ω≈°en√° pr≈Øhlednost na 50% */
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
        }

        .sliding-panel.open {
            transform: translateY(-100%);
        }

        .panel-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1001;
            transition: transform 0.3s ease-in-out;
        }

        .panel-toggle.panel-open {
            transform: translateY(calc(-1 * var(--panel-height, 50vh)));
        }

        .panel-content {
            padding: 30px 20px 20px 20px; /* Zvƒõt≈°it horn√≠ padding pro t√°hlo */
            height: calc(100% - 50px);
            overflow-y: auto;
        }

        /* P≈ôidat t√°hlo pro resize */
        .panel-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: #f0f0f0;
            cursor: row-resize;
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #ddd;
        }

        /* Vizu√°ln√≠ indik√°tor pro t√°hlo */
        .panel-handle::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 4px;
            background: #ccc;
            border-radius: 4px;
        }

        /* P≈ôizp≈Øsoben√≠ pro mobiln√≠ za≈ô√≠zen√≠ */
        @media (max-width: 768px) {
            .sliding-panel {
                width: 100%;
                right: 0;
            }
        }

        /* P≈ôidat nov√Ω styl pro playback controls */
        .playback-controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.5); /* Zv√Ω≈°en√° pr≈Øhlednost na 50% */
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px); /* Rozmazan√© pozad√≠ */
            -webkit-backdrop-filter: blur(5px); /* Pro Safari */
            z-index: 1002;
            display: flex;
            gap: 8px;
            transition: transform 0.3s ease-in-out;
        }

        .playback-controls.panel-open {
            transform: translate(-50%, calc(-1 * var(--panel-height, 50vh)));
        }

        .playback-controls button {
            width: 36px;
            height: 36px;
            border-radius: 5px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background-color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .playback-controls button:hover {
            background-color: #f0f0f0;
        }

        .playback-controls .speed-controls {
            display: flex;
            gap: 4px;
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid rgba(0, 0, 0, 0.1);
        }

        .playback-speed {
            font-size: 14px;
            line-height: 36px;
            margin: 0 8px;
            white-space: nowrap;
            color: rgba(0, 0, 0, 0.8);
        }

        /* Optimalizace pro mobiln√≠ za≈ô√≠zen√≠ */
        @media (max-width: 768px) {
            .playback-controls {
                bottom: 60px;
                padding: 6px;
                gap: 4px;
                width: 90%; /* Omezen√≠ ≈°√≠≈ôky na mobilech */
                max-width: 400px; /* Maxim√°ln√≠ ≈°√≠≈ôka */
            }

            .playback-controls button {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }

            .playback-controls .speed-controls {
                margin-left: 8px;
                padding-left: 8px;
            }

            .playback-speed {
                font-size: 12px;
                line-height: 32px;
                margin: 0 4px;
            }
        }

        /* Orientace na ≈°√≠≈ôku pro mobiln√≠ za≈ô√≠zen√≠ */
        @media (max-height: 500px) {
            .playback-controls {
                bottom: auto;
                top: 10px;
            }
        }

        /* Styl pro k≈ô√≠≈æek p≈ôi podr≈æen√≠ */
        .cross-marker {
            position: absolute;
            pointer-events: none; /* Aby k≈ô√≠≈æek nebr√°nil interakci s canvasem */
            z-index: 1005;
            display: none;
            transform: translate(-50%, -50%); /* Vycentrov√°n√≠ k≈ô√≠≈æku */
        }
        
        .cross-marker::before,
        .cross-marker::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 0, 0, 0.8);
        }
        
        .cross-marker::before {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .cross-marker::after {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Toggle button for controls */
        .controls-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            z-index: 1003;
            cursor: pointer;
            font-size: 14px;
            border: 1px solid #ccc;
            width: 40px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .controls-toggle:hover {
            background-color: rgba(240, 240, 240, 0.9);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="grid-canvas"></canvas>
        <div class="controls">
            <button id="zoom-in">+</button>
            <button id="zoom-out">‚àí</button>
            <button id="reset" title="Reset zobrazen√≠">‚Ü∫</button>
        </div>
        <div class="coordinates" id="coord-display">X: 0, Z: 0</div>
        <div class="cross-marker" id="cross-marker"></div>
        <div id="debug-display" style="position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 5px; font-size: 12px; display: none;"></div>
    </div>

    <div class="playback-controls" id="playback-controls">
        <button id="step-backward" title="Krok vzad">‚èÆ</button>
        <button id="play-pause" title="P≈ôehr√°t/Pozastavit">‚ñ∂</button>
        <button id="step-forward" title="Krok vp≈ôed">‚è≠</button>
        <button id="stop" title="Stop">‚èπ</button>
        <div class="speed-controls">
            <button id="speed-down" title="Sn√≠≈æit rychlost">‚àí</button>
            <span class="playback-speed" id="speed-display">1√ó</span>
            <button id="speed-up" title="Zv√Ω≈°it rychlost">+</button>
            <button id="speed-reset" title="Resetovat rychlost">‚Ü∫</button>
        </div>
        <button id="controls-toggle" title="Zobrazit/skr√Ωt ovl√°d√°n√≠">üëÅÔ∏è</button>
        <button id="panel-toggle" title="Otev≈ô√≠t/zav≈ô√≠t panel">‚ò∞</button>
    </div>

    <div class="sliding-panel" id="sliding-panel">
        <div class="panel-handle" id="panel-handle"></div>
        <div class="panel-content">
            <h2>Informaƒçn√≠ Panel</h2>
            <p>Zde m≈Ø≈æete p≈ôidat libovoln√Ω obsah...</p>
        </div>
    </div>

    <script>
        // Z√°kladn√≠ nastaven√≠
        const canvas = document.getElementById('grid-canvas');
        const ctx = canvas.getContext('2d');
        const coordDisplay = document.getElementById('coord-display');
        const crossMarker = document.getElementById('cross-marker');
        const debugDisplay = document.getElementById('debug-display');

        // V√Ωchoz√≠ nastaven√≠ pro m≈ô√≠≈æku
        let scale = 40; // Poƒçet pixel≈Ø na jednotku
        let offsetX = 0; // Posun ve smƒõru X
        let offsetY = 0; // Posun ve smƒõru Y
        let isDragging = false;
        let lastX, lastY;
        let minGridSpacing = 30; // Minim√°ln√≠ mezera mezi ƒçarami m≈ô√≠≈æky v pixelech
        
        // Promƒõnn√© pro sledov√°n√≠ stavu podr≈æen√≠
        let isHolding = false;
        let holdTimer = null;
        let holdDuration = 300; // Doba v ms, po kterou mus√≠ b√Ωt tlaƒç√≠tko/dotek podr≈æen
        
        // Promƒõnn√© pro pinch-to-zoom
        let initialPinchDistance = 0;
        let initialScale = 0;
        let lastPinchCenter = { x: 0, y: 0 };

        // Nastaven√≠ velikosti canvasu podle okna
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawGrid();
        }

        // Inicializace po naƒçten√≠ str√°nky
        window.addEventListener('load', () => {
            resizeCanvas();

            // Nastaven√≠ poƒç√°teƒçn√≠ pozice a mƒõ≈ô√≠tka pro zobrazen√≠ rozsahu 0-700 na vodorovn√© ose
            const targetRightX = 700;
            scale = canvas.width / targetRightX; // Mƒõ≈ô√≠tko, aby se zobrazil rozsah 0-700

            // Um√≠stit poƒç√°tek sou≈ôadnic do lev√©ho doln√≠ho rohu s offsetem
            offsetX = 25;  // Reduced by 50% (from 50px to 25px) from left edge
            offsetY = canvas.height - 168;  // Increased by 50% more (from 112px to 168px) from bottom edge

            drawGrid();
        });

        // Reagovat na zmƒõnu velikosti okna
        window.addEventListener('resize', resizeCanvas);

        // Funkce pro vykreslen√≠ m≈ô√≠≈æky
        function drawGrid() {
            // Vyƒçistit canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Urƒçit, zda je viditeln√Ω st≈ôedov√Ω k≈ô√≠≈æ
            const isOriginXVisible = offsetX > 0 && offsetX < canvas.width;
            const isOriginYVisible = offsetY > 0 && offsetY < canvas.height;
            const isOriginVisible = isOriginXVisible && isOriginYVisible;

            // Vypoƒç√≠tat viditelnou oblast v sou≈ôadnic√≠ch m≈ô√≠≈æky
            const viewportLeft = -offsetX / scale;
            const viewportRight = (canvas.width - offsetX) / scale;
            const viewportTop = -offsetY / scale;
            const viewportBottom = (canvas.height - offsetY) / scale;

            // Urƒçit vhodn√Ω interval m≈ô√≠≈æky na z√°kladƒõ p≈ôibl√≠≈æen√≠
            const gridInterval = determineGridInterval(scale);

            // Vypoƒç√≠tat poƒç√°teƒçn√≠ a koncov√© pozice ƒçar
            const startX = Math.floor(viewportLeft / gridInterval) * gridInterval;
            const endX = Math.ceil(viewportRight / gridInterval) * gridInterval;
            const startY = Math.floor(viewportTop / gridInterval) * gridInterval;
            const endY = Math.ceil(viewportBottom / gridInterval) * gridInterval;

            // Vykreslit osy (silnƒõj≈°√≠ st≈ôedov√Ω k≈ô√≠≈æ)
            if (isOriginXVisible || isOriginYVisible) {
                // Tlou≈°≈•ka st≈ôedov√©ho k≈ô√≠≈æe je vƒõt≈°√≠
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#000000';
                ctx.beginPath();

                // Osa X
                if (isOriginYVisible) {
                    ctx.moveTo(0, offsetY);
                    ctx.lineTo(canvas.width, offsetY);
                }

                // Osa Y
                if (isOriginXVisible) {
                    ctx.moveTo(offsetX, 0);
                    ctx.lineTo(offsetX, canvas.height);
                }

                ctx.stroke();
            }

            // Vykreslit m≈ô√≠≈æku (bƒõ≈æn√© ƒç√°ry)
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#aaaaaa';
            ctx.beginPath();

            // Vertik√°ln√≠ ƒç√°ry
            for (let x = startX; x <= endX; x += gridInterval) {
                if (x === 0) continue; // P≈ôeskoƒçit osu Y, ta u≈æ je vykreslena v√Ω≈°e
                const pixelX = offsetX + x * scale;
                ctx.moveTo(pixelX, 0);
                ctx.lineTo(pixelX, canvas.height);
            }

            // Horizont√°ln√≠ ƒç√°ry
            for (let y = startY; y <= endY; y += gridInterval) {
                if (y === 0) continue; // P≈ôeskoƒçit osu X, ta u≈æ je vykreslena v√Ω≈°e
                const pixelY = offsetY + y * scale;
                ctx.moveTo(0, pixelY);
                ctx.lineTo(canvas.width, pixelY);
            }

            ctx.stroke();

            // Nastaven√≠ p√≠sma pro bƒõ≈æn√© hodnoty
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333333';

            // Naj√≠t pozici druh√© m≈ô√≠≈æky od ka≈æd√©ho okraje (m√≠sto t≈ôet√≠)
            const secondGridLeft = startX + 2 * gridInterval;
            const secondGridRight = endX - 2 * gridInterval;
            const secondGridTop = startY + 2 * gridInterval;
            const secondGridBottom = endY - 2 * gridInterval;

            // Pozice druh√© m≈ô√≠≈æky v pixelech
            const secondPixelLeft = offsetX + secondGridLeft * scale;
            const secondPixelRight = offsetX + secondGridRight * scale;
            const secondPixelTop = offsetY + secondGridTop * scale;
            const secondPixelBottom = offsetY + secondGridBottom * scale;

            // Vykreslit hodnoty na m≈ô√≠≈æce
            // Vertik√°ln√≠ ƒç√°ry - hodnoty X
            for (let x = startX; x <= endX; x += gridInterval) {
                if (x === 0) continue; // Hodnotu pro 0 vykresl√≠me zvl√°≈°≈•
                const pixelX = offsetX + x * scale;
                const formattedX = parseFloat(x.toFixed(3)).toString();

                // Rozhodnut√≠, kde vykreslit hodnotu X
                if (isOriginYVisible) {
                    // Pokud je viditeln√° osa X, vykresli hodnotu na ose
                    ctx.fillText(formattedX, pixelX + 5, offsetY + 15);
                } else if (offsetY > canvas.height / 2) {
                    // St≈ôed je pod doln√≠ polovinou - vykresli bl√≠≈æe ke st≈ôedu, tedy naho≈ôe
                    ctx.fillText(formattedX, pixelX + 5, canvas.height - secondPixelTop + 15);
                } else {
                    // St≈ôed je nad horn√≠ polovinou - vykresli bl√≠≈æe ke st≈ôedu, tedy dole
                    ctx.fillText(formattedX, pixelX + 5, secondPixelBottom - 15);
                }
            }

            // Horizont√°ln√≠ ƒç√°ry - hodnoty Z
            for (let y = startY; y <= endY; y += gridInterval) {
                if (y === 0) continue; // Hodnotu pro 0 vykresl√≠me zvl√°≈°≈•
                const pixelY = offsetY + y * scale;
                const formattedY = parseFloat((-y).toFixed(3)).toString();

                // Rozhodnut√≠, kde vykreslit hodnotu Z
                if (isOriginXVisible) {
                    // Pokud je viditeln√° osa Y, vykresli hodnotu na ose
                    ctx.fillText(formattedY, offsetX + 5, pixelY + 15);
                } else if (offsetX > canvas.width / 2) {
                    // St≈ôed je vpravo od pl√°tna - vykresli bl√≠≈æe ke st≈ôedu, tedy vpravo
                    // Pou≈æijeme pevn√Ω offset od prav√©ho okraje pro konzistentnƒõj≈°√≠ zobrazen√≠
                    ctx.fillText(formattedY, canvas.width - 50, pixelY + 15);
                } else {
                    // St≈ôed je vlevo od pl√°tna - vykresli bl√≠≈æe ke st≈ôedu, tedy vlevo
                    // Pou≈æijeme pevn√Ω offset od lev√©ho okraje pro konzistentnƒõj≈°√≠ zobrazen√≠
                    ctx.fillText(formattedY, 50, pixelY + 15);
                }
            }

            // Vykreslit poƒç√°tek sou≈ôadnic s vƒõt≈°√≠mi popisky
            if (isOriginVisible) {
                // ƒåerven√Ω bod v poƒç√°tku
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, 4, 0, 2 * Math.PI); // Vƒõt≈°√≠ bod
                ctx.fill();

                // Vƒõt≈°√≠ p√≠smo pro hodnotu 0
                ctx.font = '14px Arial';
                ctx.fillStyle = '#000000'; // Tmav≈°√≠ barva pro lep≈°√≠ viditelnost
                ctx.fillText('0', offsetX + 6, offsetY + 16);
            }

            // Zobrazit referenƒçn√≠ hodnoty na okraj√≠ch, pokud nen√≠ vidƒõt st≈ôedov√Ω k≈ô√≠≈æ
            if (!isOriginVisible) {
                ctx.font = '12px Arial';
                ctx.fillStyle = '#333333';

                // Referenƒçn√≠ hodnoty pro viditelnou oblast
                const leftEdgeValue = parseFloat(viewportLeft.toFixed(3)).toString();
                const rightEdgeValue = parseFloat(viewportRight.toFixed(3)).toString();
                const topEdgeValue = parseFloat((-viewportTop).toFixed(3)).toString();
                const bottomEdgeValue = parseFloat((-viewportBottom).toFixed(3)).toString();

                // Zobrazit hodnoty na okraj√≠ch
                ctx.fillText(`X: ${leftEdgeValue}`, 10, canvas.height - 10);
                ctx.fillText(`X: ${rightEdgeValue}`, canvas.width - 80, canvas.height - 10);
                ctx.fillText(`Z: ${topEdgeValue}`, canvas.width - 80, 20);
                ctx.fillText(`Z: ${bottomEdgeValue}`, canvas.width - 80, canvas.height - 30);
            }
        }

        // Funkce pro urƒçen√≠ vhodn√©ho intervalu m≈ô√≠≈æky
        function determineGridInterval(scale) {
            // Z√°klad pro intervaly (mocniny 10)
            const base = 10;

            // Z√°kladn√≠ interval je 1
            let interval = 1;

            // Pokud jsme p≈ô√≠li≈° p≈ôibl√≠≈æeni, zmen≈°ujeme interval
            while (interval * scale > minGridSpacing * 2) {
                interval /= base;
            }

            // Pokud jsme p≈ô√≠li≈° odd√°leni, zvƒõt≈°ujeme interval
            while (interval * scale < minGridSpacing) {
                interval *= base;
            }

            // Pro lep≈°√≠ vzhled m≈Ø≈æeme p≈ôidat mezihodnoty (2, 5)
            const refinedIntervals = [1, 2, 5, 10];
            let magnitude = Math.pow(10, Math.floor(Math.log10(interval)));

            for (let i = 0; i < refinedIntervals.length; i++) {
                let refined = refinedIntervals[i] * magnitude;
                if (refined * scale >= minGridSpacing) {
                    return refined;
                }
            }

            return interval;
        }

        // Ovl√°d√°n√≠ pro zoom a posun
        document.getElementById('zoom-in').addEventListener('click', () => {
            scale *= 1.2;
            drawGrid();
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            scale /= 1.2;
            drawGrid();
        });

        document.getElementById('reset').addEventListener('click', () => {
            // Nastaven√≠ mƒõ≈ô√≠tka pro zobrazen√≠ rozsahu 0-700 na vodorovn√© ose
            const targetRightX = 700;
            scale = canvas.width / targetRightX;

            // Resetovat do lev√©ho doln√≠ho rohu (m√≠sto do st≈ôedu)
            offsetX = 25;  // Reduced by 50% (from 50px to 25px) from left edge
            offsetY = canvas.height - 168;  // Increased by 50% more (from 75px to 168px) from bottom edge
            drawGrid();
        });

        // Ud√°lost pro koleƒçko my≈°i - zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Z√≠skat sou≈ôadnice my≈°i p≈ôed zoomem
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Vypoƒç√≠tat sou≈ôadnice v m≈ô√≠≈æce
            const gridX = (mouseX - offsetX) / scale;
            const gridY = (mouseY - offsetY) / scale;

            // Upravit mƒõ≈ô√≠tko podle smƒõru koleƒçka
            if (e.deltaY < 0) {
                scale *= 1.1; // P≈ôibl√≠≈æit
            } else {
                scale /= 1.1; // Odd√°lit
            }

            // Upravit posun, aby bod pod kurzorem z≈Østal na stejn√©m m√≠stƒõ
            offsetX = mouseX - gridX * scale;
            offsetY = mouseY - gridY * scale;

            drawGrid();
        });

        // Ud√°losti pro ta≈æen√≠ my≈°√≠
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
            
            // Zaƒç√≠t odpoƒçet pro podr≈æen√≠
            startHoldTimer(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            // Aktualizovat zobrazen√≠ sou≈ôadnic a opravit nep≈ôesnosti plovouc√≠ desetinn√© ƒç√°rky
            const rawX = (e.clientX - offsetX) / scale;
            const rawY = -(e.clientY - offsetY) / scale;
            // Zaokrouhlit na 3 desetinn√° m√≠sta a pak zobrazit
            const gridX = parseFloat(rawX.toFixed(3)).toString();
            const gridY = parseFloat(rawY.toFixed(3)).toString();
            
            // Zobrazit sou≈ôadnice pouze pokud nen√≠ aktivn√≠ k≈ô√≠≈æek
            if (!isHolding) {
                coordDisplay.textContent = `X: ${gridX}, Z: ${gridY}`;
            }

            if (isDragging) {
                // Pokud se u≈æivatel pohybuje, zru≈°it odpoƒçet pro podr≈æen√≠
                clearHoldTimer();
                
                // Pokud je zobrazen k≈ô√≠≈æek a u≈æivatel se pohybuje, aktualizovat jeho pozici
                if (isHolding) {
                    updateCrossMarkerPosition(e.clientX, e.clientY);
                } else {
                    // Standardn√≠ posun pl√°tna
                    offsetX += e.clientX - lastX;
                    offsetY += e.clientY - lastY;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    drawGrid();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'default';
            clearHoldTimer();
            hideCrossMarker();
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'default';
            clearHoldTimer();
            hideCrossMarker();
        });
        
        // Ud√°losti pro dotykov√© ovl√°d√°n√≠ - kompletnƒõ p≈ôepracovan√©
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Zabr√°nit v√Ωchoz√≠mu chov√°n√≠ prohl√≠≈æeƒçe
            
            // Detekce pinch gesta (dva prsty)
            if (e.touches.length === 2) {
                // V≈ædy skr√Ωt k≈ô√≠≈æek p≈ôi pou≈æit√≠ dvou prst≈Ø
                isHolding = false;
                crossMarker.style.display = 'none';
                clearHoldTimer();
                
                // Ulo≈æit poƒç√°teƒçn√≠ vzd√°lenost mezi prsty
                initialPinchDistance = getPinchDistance(e.touches);
                initialScale = scale;
                
                // Ulo≈æit st≈ôed pinch gesta
                lastPinchCenter = getPinchCenter(e.touches);
                return;
            }
            
            // Standardn√≠ chov√°n√≠ pro jeden prst
            isDragging = true;
            lastX = e.touches[0].clientX;
            lastY = e.touches[0].clientY;
            
            // Zaƒç√≠t odpoƒçet pro podr≈æen√≠
            startHoldTimer(e.touches[0].clientX, e.touches[0].clientY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Zabr√°nit v√Ωchoz√≠mu chov√°n√≠ prohl√≠≈æeƒçe
            
            // Pinch-to-zoom (dva prsty)
            if (e.touches.length === 2) {
                // V≈ædy skr√Ωt k≈ô√≠≈æek p≈ôi pou≈æit√≠ dvou prst≈Ø
                isHolding = false;
                crossMarker.style.display = 'none';
                clearHoldTimer();
                
                // Vypoƒç√≠tat aktu√°ln√≠ vzd√°lenost mezi prsty
                const currentDistance = getPinchDistance(e.touches);
                
                // Z√≠skat st≈ôed pinch gesta
                const currentCenter = getPinchCenter(e.touches);
                
                // Zmƒõnit mƒõ≈ô√≠tko podle zmƒõny vzd√°lenosti
                if (initialPinchDistance > 0) {
                    // Vypoƒç√≠tat pomƒõr zmƒõny vzd√°lenosti
                    const pinchRatio = currentDistance / initialPinchDistance;
                    
                    // Vypoƒç√≠tat nov√© mƒõ≈ô√≠tko
                    const newScale = Math.max(5, Math.min(initialScale * pinchRatio, 200));
                    
                    // Upravit offset tak, aby se zachoval st≈ôed zoomu
                    if (newScale !== scale) {
                        // P≈ôizp≈Øsobit offset, aby se zachoval st≈ôed pinch gesta
                        const zoomFactor = newScale / scale;
                        const centerX = currentCenter.x;
                        const centerY = currentCenter.y;
                        
                        offsetX = centerX - (centerX - offsetX) * zoomFactor;
                        offsetY = centerY - (centerY - offsetY) * zoomFactor;
                        
                        // Aktualizovat mƒõ≈ô√≠tko
                        scale = newScale;
                        
                        // P≈ôekreslit m≈ô√≠≈æku
                        drawGrid();
                    }
                }
                
                // Aktualizovat posledn√≠ st≈ôed
                lastPinchCenter = currentCenter;
                return;
            }
            
            // Standardn√≠ chov√°n√≠ pro jeden prst
            if (isDragging) {
                const deltaX = e.touches[0].clientX - lastX;
                const deltaY = e.touches[0].clientY - lastY;
                
                // Pokud se u≈æivatel pohybuje, zru≈°it odpoƒçet pro podr≈æen√≠
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5 && !isHolding) {
                    clearHoldTimer();
                }
                
                if (isHolding) {
                    // Pokud je aktivn√≠ podr≈æen√≠, aktualizovat pozici k≈ô√≠≈æku
                    updateCrossMarkerPosition(e.touches[0].clientX, e.touches[0].clientY);
                } else {
                    // Jinak standardn√≠ posun pl√°tna
                    offsetX += deltaX;
                    offsetY += deltaY;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    drawGrid();
                }
            }
            
            // Aktualizovat zobrazen√≠ sou≈ôadnic
            if (e.touches.length > 0 && !isHolding) {
                const rawX = (e.touches[0].clientX - offsetX) / scale;
                const rawY = -(e.touches[0].clientY - offsetY) / scale;
                const gridX = parseFloat(rawX.toFixed(3)).toString();
                const gridY = parseFloat(rawY.toFixed(3)).toString();
                
                coordDisplay.textContent = `X: ${gridX}, Z: ${gridY}`;
            }
        });
        
        // P≈ôidat touchend event handler
        canvas.addEventListener('touchend', (e) => {
            // Reset pinch-to-zoom variables when touch ends
            initialPinchDistance = 0;
            
            // Pokud nen√≠ ≈æ√°dn√Ω prst na obrazovce, resetovat v≈°echna stavy
            if (e.touches.length === 0) {
                isDragging = false;
                isHolding = false;
                clearHoldTimer();
                crossMarker.style.display = 'none';
            }
            
            // Pokud z≈Østal jeden prst, aktualizovat pozici
            if (e.touches.length === 1) {
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                
                // Resetovat stav dr≈æen√≠ p≈ôi zmƒõnƒõ poƒçtu prst≈Ø
                isHolding = false;
                clearHoldTimer();
                crossMarker.style.display = 'none';
                
                // Zaƒç√≠t nov√Ω odpoƒçet pro podr≈æen√≠
                startHoldTimer(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        
        // P≈ôidat touchcancel event pro √∫plnost
        canvas.addEventListener('touchcancel', () => {
            isDragging = false;
            isHolding = false;
            clearHoldTimer();
            crossMarker.style.display = 'none';
            initialPinchDistance = 0;
        });
        
        // Funkce pro v√Ωpoƒçet vzd√°lenosti mezi dvƒõma dotyky
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Funkce pro v√Ωpoƒçet st≈ôedu mezi dvƒõma dotyky
        function getPinchCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }
        
        // Funkce pro pr√°ci s k≈ô√≠≈ækem p≈ôi podr≈æen√≠
        function startHoldTimer(x, y) {
            clearHoldTimer(); // Vyƒçistit existuj√≠c√≠ ƒçasovaƒç
            
            holdTimer = setTimeout(() => {
                isHolding = true;
                crossMarker.style.display = 'block';
                updateCrossMarkerPosition(x, y);
            }, holdDuration);
        }
        
        function clearHoldTimer() {
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }
        }
        
        function hideCrossMarker() {
            // V≈ædy resetovat stav dr≈æen√≠ a skr√Ωt k≈ô√≠≈æek
            isHolding = false;
            crossMarker.style.display = 'none';
        }
        
        function updateCrossMarkerPosition(x, y) {
            // Pou≈æ√≠t stejn√Ω offset 80px pro v≈°echna za≈ô√≠zen√≠
            const markerOffsetY = 80;
            
            // Aktualizovat pozici k≈ô√≠≈æku - k≈ô√≠≈æek je jen vizu√°ln√≠ pom≈Øcka
            // a je posunut√Ω nad prst/my≈°
            const markerX = x;
            const markerY = y - markerOffsetY;
            crossMarker.style.left = `${markerX}px`;
            crossMarker.style.top = `${markerY}px`;
            
            // V√Ωpoƒçet sou≈ôadnic PRO POZICI K≈ò√ç≈ΩKU (ne pro pozici my≈°i/prstu)
            const rawX = (markerX - offsetX) / scale;
            const rawY = -(markerY - offsetY) / scale;
            
            // Zaokrouhlit na 3 desetinn√° m√≠sta a pak zobrazit
            const gridX = parseFloat(rawX.toFixed(3)).toString();
            const gridY = parseFloat(rawY.toFixed(3)).toString();
            
            // Aktualizovat zobrazen√≠ sou≈ôadnic - pou≈æ√≠t sou≈ôadnice k≈ô√≠≈æku
            coordDisplay.textContent = `X: ${gridX}, Z: ${gridY}`;
            
            // Pro √∫ƒçely ladƒõn√≠
            debugDisplay.style.display = 'none';
            // debugDisplay.innerHTML = `
            //     Pozice my≈°i/prstu: x=${x}, y=${y}<br>
            //     Pozice k≈ô√≠≈æku: x=${markerX}, y=${markerY}<br>
            //     Offset: offsetX=${offsetX}, offsetY=${offsetY}<br>
            //     Scale: ${scale}<br>
            //     V√Ωpoƒçet X: (${markerX} - ${offsetX}) / ${scale} = ${gridX}<br>
            //     V√Ωpoƒçet Z: -(${markerY} - ${offsetY}) / ${scale} = ${gridY}
            // `;
        }

        // Ovl√°d√°n√≠ vysouvac√≠ho panelu
        const panelToggle = document.getElementById('panel-toggle');
        const slidingPanel = document.getElementById('sliding-panel');
        const canvasContainer = document.getElementById('canvas-container');
        const controls = document.querySelector('.controls'); // P≈ôid√°n v√Ωbƒõr controls
        const playbackControls = document.getElementById('playback-controls');
        let isPanelOpen = false;

        panelToggle.addEventListener('click', () => {
            isPanelOpen = !isPanelOpen;
            const height = slidingPanel.offsetHeight;
            root.style.setProperty('--panel-height', `${height}px`);
            slidingPanel.classList.toggle('open');
            canvasContainer.classList.toggle('panel-open');
            controls.classList.toggle('panel-open'); // P≈ôidat zpƒõt transformaci controls
            playbackControls.classList.toggle('panel-open'); // P≈ôidat transformaci pro playback controls
        });

        // P≈ôidat nov√Ω k√≥d pro resize panelu
        const panelHandle = document.getElementById('panel-handle');
        const root = document.documentElement;
        let startY;
        let startHeight;

        function initPanelResize() {
            panelHandle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function startResize(e) {
            startY = e.clientY;
            startHeight = slidingPanel.offsetHeight;
            document.body.style.cursor = 'row-resize';
            e.preventDefault();
        }

        function resize(e) {
            if (startY) {
                const delta = startY - e.clientY;
                const newHeight = Math.min(Math.max(startHeight + delta, 200), window.innerHeight * 0.9);
                slidingPanel.style.height = `${newHeight}px`;
                root.style.setProperty('--panel-height', `${newHeight}px`);

                if (isPanelOpen) {
                    slidingPanel.style.bottom = `-${newHeight}px`;
                }
            }
        }

        function stopResize() {
            startY = null;
            document.body.style.cursor = '';
        }

        // Inicializovat resize funkcionalitu
        initPanelResize();

        // P≈ôidat p≈ôed inicializaci panel resize
        const playPauseBtn = document.getElementById('play-pause');
        const stepBackwardBtn = document.getElementById('step-backward');
        const stepForwardBtn = document.getElementById('step-forward');
        const stopBtn = document.getElementById('stop');
        const speedDownBtn = document.getElementById('speed-down');
        const speedUpBtn = document.getElementById('speed-up');
        const speedResetBtn = document.getElementById('speed-reset');
        const speedDisplay = document.getElementById('speed-display');

        let isPlaying = false;
        let playbackSpeed = 1;

        // Funkce pro ovl√°d√°n√≠ p≈ôehr√°vaƒçe
        playPauseBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playPauseBtn.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
            // TODO: Implementovat logiku p≈ôehr√°v√°n√≠
        });

        stopBtn.addEventListener('click', () => {
            isPlaying = false;
            playPauseBtn.textContent = '‚ñ∂';
            // TODO: Implementovat logiku zastaven√≠
        });

        stepBackwardBtn.addEventListener('click', () => {
            // TODO: Implementovat logiku kroku vzad
        });

        stepForwardBtn.addEventListener('click', () => {
            // TODO: Implementovat logiku kroku vp≈ôed
        });

        speedUpBtn.addEventListener('click', () => {
            playbackSpeed = Math.min(playbackSpeed * 2, 16);
            speedDisplay.textContent = playbackSpeed + '√ó';
        });

        speedDownBtn.addEventListener('click', () => {
            playbackSpeed = Math.max(playbackSpeed / 2, 0.25);
            speedDisplay.textContent = playbackSpeed + '√ó';
        });

        speedResetBtn.addEventListener('click', () => {
            playbackSpeed = 1;
            speedDisplay.textContent = '1√ó';
        });

        // Controls toggle functionality
        const controlsToggleBtn = document.getElementById('controls-toggle');
        const controlsPanel = document.querySelector('.controls');
        let controlsVisible = true;
        
        controlsToggleBtn.addEventListener('click', () => {
            controlsVisible = !controlsVisible;
            controlsPanel.classList.toggle('hidden', !controlsVisible);
        });

        // P≈ôidat novou funkƒçnost pro tlaƒç√≠tko zobrazen√≠/skryt√≠ ovl√°d√°n√≠
        const controlsVisibilityBtn = document.getElementById('controls-visibility');
        if (controlsVisibilityBtn) {
            controlsVisibilityBtn.addEventListener('click', () => {
                controlsPanel.classList.toggle('hidden');
            });
        }
    </script>
</body>
</html>
